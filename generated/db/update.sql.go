// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: update.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUpdate = `-- name: CreateUpdate :exec
INSERT INTO updates (id,
                     project_id,
                     runtime_version,
                     message,
                     channel,
                     status,
                     created_at)
VALUES ($1, $2, $3, $4, $5, 'empty', current_timestamp)
`

type CreateUpdateParams struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	RuntimeVersion string
	Message        pgtype.Text
	Channel        string
}

func (q *Queries) CreateUpdate(ctx context.Context, arg CreateUpdateParams) error {
	_, err := q.db.Exec(ctx, createUpdate,
		arg.ID,
		arg.ProjectID,
		arg.RuntimeVersion,
		arg.Message,
		arg.Channel,
	)
	return err
}

type CreateUpdateAssetsParams struct {
	ID                uuid.UUID
	UpdateID          uuid.UUID
	StorageObjectPath string
	ContentType       string
	Extension         string
	ContentMd5        string
	ContentSha256     string
	IsLaunchAsset     bool
	IsArchive         bool
	Platform          string
	ContentLength     int64
}

const createUpdateMetadata = `-- name: CreateUpdateMetadata :exec
INSERT INTO update_metadata (id,
                             update_id,
                             expo_app_config,
                             created_at)
VALUES ($1, $2, $3, current_timestamp)
`

func (q *Queries) CreateUpdateMetadata(ctx context.Context, iD uuid.UUID, updateID uuid.UUID, expoAppConfig []byte) error {
	_, err := q.db.Exec(ctx, createUpdateMetadata, iD, updateID, expoAppConfig)
	return err
}

const getLastNUpdates = `-- name: GetLastNUpdates :many
SELECT id, project_id, runtime_version, status, message, channel, created_at
FROM updates
WHERE project_id = $2
  AND (runtime_version = $3 OR $3 IS NULL)
  AND (status = $4 OR $4 IS NULL)
  AND (channel = $5 OR $5 IS NULL)
ORDER BY created_at DESC
LIMIT $1
`

type GetLastNUpdatesParams struct {
	Limit          int32
	ProjectID      uuid.UUID
	RuntimeVersion pgtype.Text
	Status         NullUpdateStatus
	Channel        pgtype.Text
}

func (q *Queries) GetLastNUpdates(ctx context.Context, arg GetLastNUpdatesParams) ([]Update, error) {
	rows, err := q.db.Query(ctx, getLastNUpdates,
		arg.Limit,
		arg.ProjectID,
		arg.RuntimeVersion,
		arg.Status,
		arg.Channel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Update
	for rows.Next() {
		var i Update
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.RuntimeVersion,
			&i.Status,
			&i.Message,
			&i.Channel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPublishedAndCanceledUpdates = `-- name: GetLatestPublishedAndCanceledUpdates :many
select distinct on (updates.status) updates.id, updates.project_id, updates.runtime_version, updates.status, updates.message, updates.channel, updates.created_at, asset.content_sha256
from updates
         left join update_assets asset
                   on updates.id = asset.update_id and
                      asset.platform = $1 and
                      (asset.is_launch_asset = true or asset.is_archive = true)
where updates.project_id = $2
  and updates.runtime_version = $3
  and updates.channel = $4
  and updates.status in ('published', 'canceled')
order by updates.status,
         case
             when asset.is_archive = true then 1 -- select archive asset if exists
             else 2
             end,
         updates.created_at desc
`

type GetLatestPublishedAndCanceledUpdatesParams struct {
	Platform       string
	ProjectID      uuid.UUID
	RuntimeVersion string
	Channel        string
}

type GetLatestPublishedAndCanceledUpdatesRow struct {
	Update        Update
	ContentSha256 pgtype.Text
}

func (q *Queries) GetLatestPublishedAndCanceledUpdates(ctx context.Context, arg GetLatestPublishedAndCanceledUpdatesParams) ([]GetLatestPublishedAndCanceledUpdatesRow, error) {
	rows, err := q.db.Query(ctx, getLatestPublishedAndCanceledUpdates,
		arg.Platform,
		arg.ProjectID,
		arg.RuntimeVersion,
		arg.Channel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestPublishedAndCanceledUpdatesRow
	for rows.Next() {
		var i GetLatestPublishedAndCanceledUpdatesRow
		if err := rows.Scan(
			&i.Update.ID,
			&i.Update.ProjectID,
			&i.Update.RuntimeVersion,
			&i.Update.Status,
			&i.Update.Message,
			&i.Update.Channel,
			&i.Update.CreatedAt,
			&i.ContentSha256,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLaunchAssetOrArchiveByPlatform = `-- name: GetLaunchAssetOrArchiveByPlatform :one
select id, update_id, storage_object_path, content_type, extension, content_md5, content_sha256, is_launch_asset, is_archive, platform, content_length, created_at
from update_assets
where update_id = $1
  and (is_launch_asset = true or is_archive = true)
  and platform = $2
order by is_archive desc, is_launch_asset desc
limit 1
`

func (q *Queries) GetLaunchAssetOrArchiveByPlatform(ctx context.Context, updateID uuid.UUID, platform string) (UpdateAsset, error) {
	row := q.db.QueryRow(ctx, getLaunchAssetOrArchiveByPlatform, updateID, platform)
	var i UpdateAsset
	err := row.Scan(
		&i.ID,
		&i.UpdateID,
		&i.StorageObjectPath,
		&i.ContentType,
		&i.Extension,
		&i.ContentMd5,
		&i.ContentSha256,
		&i.IsLaunchAsset,
		&i.IsArchive,
		&i.Platform,
		&i.ContentLength,
		&i.CreatedAt,
	)
	return i, err
}

const getUpdateAssetsByPlatform = `-- name: GetUpdateAssetsByPlatform :many
select id, update_id, storage_object_path, content_type, extension, content_md5, content_sha256, is_launch_asset, is_archive, platform, content_length, created_at
from update_assets
where update_id = $1
  and platform = $2
  and is_archive = false
`

func (q *Queries) GetUpdateAssetsByPlatform(ctx context.Context, updateID uuid.UUID, platform string) ([]UpdateAsset, error) {
	rows, err := q.db.Query(ctx, getUpdateAssetsByPlatform, updateID, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdateAsset
	for rows.Next() {
		var i UpdateAsset
		if err := rows.Scan(
			&i.ID,
			&i.UpdateID,
			&i.StorageObjectPath,
			&i.ContentType,
			&i.Extension,
			&i.ContentMd5,
			&i.ContentSha256,
			&i.IsLaunchAsset,
			&i.IsArchive,
			&i.Platform,
			&i.ContentLength,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpdateByID = `-- name: GetUpdateByID :one
select id, project_id, runtime_version, status, message, channel, created_at
from updates
where id = $1
  and project_id = $2
limit 1
`

func (q *Queries) GetUpdateByID(ctx context.Context, updateID uuid.UUID, projectID uuid.UUID) (Update, error) {
	row := q.db.QueryRow(ctx, getUpdateByID, updateID, projectID)
	var i Update
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RuntimeVersion,
		&i.Status,
		&i.Message,
		&i.Channel,
		&i.CreatedAt,
	)
	return i, err
}

const getUpdateByIDWithProtocol = `-- name: GetUpdateByIDWithProtocol :one
select u.id, u.project_id, u.runtime_version, u.status, u.message, u.channel, u.created_at, p.update_protocol as protocol
from updates u
         inner join projects p on u.project_id = p.id
where u.id = $1
limit 1
`

type GetUpdateByIDWithProtocolRow struct {
	ID             uuid.UUID
	ProjectID      uuid.UUID
	RuntimeVersion string
	Status         UpdateStatus
	Message        pgtype.Text
	Channel        string
	CreatedAt      pgtype.Timestamptz
	Protocol       UpdateProtocol
}

func (q *Queries) GetUpdateByIDWithProtocol(ctx context.Context, updateID uuid.UUID) (GetUpdateByIDWithProtocolRow, error) {
	row := q.db.QueryRow(ctx, getUpdateByIDWithProtocol, updateID)
	var i GetUpdateByIDWithProtocolRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RuntimeVersion,
		&i.Status,
		&i.Message,
		&i.Channel,
		&i.CreatedAt,
		&i.Protocol,
	)
	return i, err
}

const setUpdateStatus = `-- name: SetUpdateStatus :one
UPDATE updates
SET status = $2
WHERE id = $1
RETURNING id, project_id, runtime_version, status, message, channel, created_at
`

func (q *Queries) SetUpdateStatus(ctx context.Context, iD uuid.UUID, status UpdateStatus) (Update, error) {
	row := q.db.QueryRow(ctx, setUpdateStatus, iD, status)
	var i Update
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RuntimeVersion,
		&i.Status,
		&i.Message,
		&i.Channel,
		&i.CreatedAt,
	)
	return i, err
}
